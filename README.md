# 编程的进化——从C语言到C++：5、语句和函数

在高级编程语言中，语句和函数是最基本的单位。C++中大部分的语句同C语言中一致，如顺序结构、选择结构和循环结构等。在此基础上C++又新增加了一些新的功能，如try-catch语句处理运行时出现的异常行为。

---

## 一. Try语句块和异常处理

所谓异常，通常指程序在运行时发生的一些未定义的、超出了程序正常功能的现象。如果某个程序在运行时出现了异常，则表明程序出现了不应有的故障，无法继续执行。此时应当对这种情况进行专门处理，否则程序极可能出现严重问题，比如崩溃掉。

程序的异常处理通常包括异常的检测和处理两部分。在C++中提供了一下方法来处理与运行时异常相关的问题：

- **throw表达式**：在遇到问题时，可以使用throw表达式人为地抛出一个异常，表示遇到了无法处理的问题。
- **try语句块**：try语句块以关键字try开始，以若干个catch子句结束。try中抛出的异常通常会被某一个catch处理，因此catch语句通常也被称作异常处理代码exception handler。 
- **异常类**：用于表示异常的具体信息。

### 1. throw表达式

throw表达式包括throw关键字和其后的表示异常类型的表达式。通常通过这种方式构成一个throw语句。

例如，假设我们在程序中的逻辑规定，某两个值不能相等，否则程序将会产生错误，那么可以采用以下方式：

	if (num1 == num2)
	{
		throw runtime_error("Num1 should not be equal to Num2.");
	}

当执行抛出异常语句时，当前函数将终止，并将程序控制权转移给处理该异常的代码。类型runtime_error是C++提供的一种标准异常类型，定义在stdexcpt头文件中。

### 2. try语句块

try语句块包括try关键字加后面紧跟的一个语句块。在try语句块之后是一个或多个catch子句，每个catch子句包括三部分：关键字catch、异常声明和catch语句块。当选中某个catch子句处理异常后，程序跳转到最后一个catch子句的后面继续向下执行。

通常try语句块的形式如：

	try
	{
		//产生异常的代码
	}
	catch (exception-declaration1)
	{
		//异常处理1
	}
	catch (exception-declaration2)
	{
		//异常处理2
	}

如何判断try语句块抛出的异常与catch对应？当一个异常被抛出时，首先会在当前函数内部查找对应的catch。如果没有找到，那么当前函数执行终止，并在当前函数的上一级继续寻找对应的catch，并如此往复执行。如果最终没能找到任何匹配的catch，那么程序将转而调用标准库函数terminate，通常此时程序将非正常退出。

### 3. 标准异常

C++标准库中定义了一组类用于函数中的异常处理。其中最为常用的定义在头文件stdexcept中，主要有：

| 异常类名 | 含义 |
|exception|通用异常类，只提示发生问题，不含额外信息|
|runtime_error| 运行时产生的异常 |
|range_error| 运行时错误，结果超出有意义的范围 |
|overflow_error|运行时错误，计算上溢|
|underflow_error|运行时错误，计算下溢|
|logic_error| 程序逻辑错误 |
|domain_error|逻辑错误：参数对应的结果值不存在|
|invalid_argument|逻辑错误：无效参数|
|length_error|逻辑错误：试图创建的对象超过类型长度限制|
|out_of_range|逻辑错误：使用超出有效范围的值|

---

##二. 引用作为函数的参数和返回值

### 1. 参数传递

我们知道，每次函数调用发生时，函数都会重新创建其形参，并用传入的实参对形参进行初始化。函数的参数传递方式通常有两种：值传递和引用传递。

- 值传递：函数的参数以数值类型传递。此时实参的值会被拷贝给形参，实参和形参是两个数值相等但是相互独立、没有关联关系的对象。需注意的是，指针传递实际上也是值传递的一种方式。虽然可以通过指针改变实参指向对象的值，但是实参和形参所表示的指针变量本身依然是独立的。
- 引用传递：如果函数的形参声明为引用类型，那么形参作为一个引用会被绑定到实参上，即引用形参是其对应的实参的别名。

将参数定义为引用类型可以实现许多传值方式无法实现的功能。首先，传值方式会导致对象进行一次复制操作。有时候参数对象可能较为庞大，此时进行复制操作会使程序的效率降低。而有些类型则完全不支持拷贝操作。此时除了使用引用传递之外别无他法。另外，如果参数是一个类，并且类包含了与对象个数相关的静态数据成员的话，经过参数传递可能会导致内部与外部的值不一致。因此，在这些场合下，应优先选择引用传递的方式。

另外，通过引用传递参数还可以作为返回额外信息的途径。在子函数向调用者传递信息的方法中，单纯靠返回值常常是不够的。在需要同时返回多个值的时候，通过引用的方式提供了一种方便的方法。比如以下的函数：

	int fun_return_2_vals(int& param)
	{
		int num1 = 3, num2 = 5; //我们希望同时将这两个值传递到外部
		param = num1;			//由于传递的是引用类型，param所对应的实参也会被num1修改
		return num2;			//通过返回值传递另一个值
	}
