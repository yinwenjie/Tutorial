# 编程的进化——从C语言到C++：5、语句和函数

在高级编程语言中，语句和函数是最基本的单位。C++中大部分的语句同C语言中一致，如顺序结构、选择结构和循环结构等。在此基础上C++又新增加了一些新的功能，如try-catch语句处理运行时出现的异常行为。

---

## 一. Try语句块和异常处理

所谓异常，通常指程序在运行时发生的一些未定义的、超出了程序正常功能的现象。如果某个程序在运行时出现了异常，则表明程序出现了不应有的故障，无法继续执行。此时应当对这种情况进行专门处理，否则程序极可能出现严重问题，比如崩溃掉。

程序的异常处理通常包括异常的检测和处理两部分。在C++中提供了一下方法来处理与运行时异常相关的问题：

- **throw表达式**：在遇到问题时，可以使用throw表达式人为地抛出一个异常，表示遇到了无法处理的问题。
- **try语句块**：try语句块以关键字try开始，以若干个catch子句结束。try中抛出的异常通常会被某一个catch处理，因此catch语句通常也被称作异常处理代码exception handler。 
- **异常类**：用于表示异常的具体信息。

### 1. throw表达式

throw表达式包括throw关键字和其后的表示异常类型的表达式。通常通过这种方式构成一个throw语句。

例如，假设我们在程序中的逻辑规定，某两个值不能相等，否则程序将会产生错误，那么可以采用以下方式：

	if (num1 == num2)
	{
		throw runtime_error("Num1 should not be equal to Num2.");
	}

当执行抛出异常语句时，当前函数将终止，并将程序控制权转移给处理该异常的代码。类型runtime_error是C++提供的一种标准异常类型，定义在stdexcpt头文件中。

### 2. try语句块

try语句块包括try关键字加后面紧跟的一个语句块。在try语句块之后是一个或多个catch子句，每个catch子句包括三部分：关键字catch、异常声明和catch语句块。当选中某个catch子句处理异常后，程序跳转到最后一个catch子句的后面继续向下执行。

通常try语句块的形式如：

	try
	{
		//产生异常的代码
	}
	catch (exception-declaration1)
	{
		//异常处理1
	}
	catch (exception-declaration2)
	{
		//异常处理2
	}

如何判断try语句块抛出的异常与catch对应？当一个异常被抛出时，首先会在当前函数内部查找对应的catch。如果没有找到，那么当前函数执行终止，并在当前函数的上一级继续寻找对应的catch，并如此往复执行。如果最终没能找到任何匹配的catch，那么程序将转而调用标准库函数terminate，通常此时程序将非正常退出。

### 3. 标准异常

C++标准库中定义了一组类用于函数中的异常处理。其中最为常用的定义在头文件stdexcept中，主要有：

| 异常类名 | 含义 |
|exception|通用异常类，只提示发生问题，不含额外信息|
|runtime_error| 运行时产生的异常 |
|range_error| 运行时错误，结果超出有意义的范围 |
|overflow_error|运行时错误，计算上溢|
|underflow_error|运行时错误，计算下溢|
|logic_error| 程序逻辑错误 |
|domain_error|逻辑错误：参数对应的结果值不存在|
|invalid_argument|逻辑错误：无效参数|
|length_error|逻辑错误：试图创建的对象超过类型长度限制|
|out_of_range|逻辑错误：使用超出有效范围的值|

---

##二. 引用作为函数的参数和返回值

### 1. 参数传递

我们知道，每次函数调用发生时，函数都会重新创建其形参，并用传入的实参对形参进行初始化。函数的参数传递方式通常有两种：值传递和引用传递。

- 值传递：函数的参数以数值类型传递。此时实参的值会被拷贝给形参，实参和形参是两个数值相等但是相互独立、没有关联关系的对象。需注意的是，指针传递实际上也是值传递的一种方式。虽然可以通过指针改变实参指向对象的值，但是实参和形参所表示的指针变量本身依然是独立的。
- 引用传递：如果函数的形参声明为引用类型，那么形参作为一个引用会被绑定到实参上，即引用形参是其对应的实参的别名。

将参数定义为引用类型可以实现许多传值方式无法实现的功能。首先，传值方式会导致对象进行一次复制操作。有时候参数对象可能较为庞大，此时进行复制操作会使程序的效率降低。而有些类型则完全不支持拷贝操作。此时除了使用引用传递之外别无他法。另外，如果参数是一个类，并且类包含了与对象个数相关的静态数据成员的话，经过参数传递可能会导致内部与外部的值不一致。因此，在这些场合下，应优先选择引用传递的方式。

另外，通过引用传递参数还可以作为返回额外信息的途径。在子函数向调用者传递信息的方法中，单纯靠返回值常常是不够的。在需要同时返回多个值的时候，通过引用的方式提供了一种方便的方法。比如以下的函数：

	int fun_return_2_vals(int& param)
	{
		int num1 = 3, num2 = 5; //我们希望同时将这两个值传递到外部
		param = num1;			//由于传递的是引用类型，param所对应的实参也会被num1修改
		return num2;			//通过返回值传递另一个值
	}


### 2. 引用作为返回值

####(1). 函数的返回

在执行到return语句时，当前函数终止执行并返回到上一级调用该函数的地方。函数返回时根据声明的类型可以是有返回值或无返回值的。只有返回类型是void型的函数才能在return时不返回任何值。其他声明为任何返回类型的函数在结束时都必须返回一个对应类型的值。

函数返回一个值的方式类似于初始化变量或形参，在函数返回时，返回值用于初始化调用点的一个临时量，并将该临时量传给调用者。也就是说，在通过数值返回的过程中，返回的对象也是进行过一次拷贝的。

####(2). 返回引用类型

如同参数声明一样，函数的返回值也可以声明为引用类型。如果声明为引用类型，那么在返回过程中将不会进行对象的拷贝，直接返回该对象自身。比如下面的程序段，比较两个int型整数并返回其中较小的一个：

	const int& int_cmp(const int &num1, const int &num2)
	{
		return num1 < num2 ? num1 : num2;
	}

在这段函数中，参数和返回值都声明为引用类型，因此无论是形参还是返回值都直接操作的是传入的实参。

由于引用类型返回值返回的是其自身，因此必须注意的一点是绝对不允许返回函数内部分配的临时对象的引用（或者指针）。因为临时对象的生命周期仅限于函数内部，在函数结束之后该对象就被释放，指向它的指针或引用将指向一个无效区域，使用它将产生错误。如以下程序是错误的：

	//错误程序：返回了临时变量的引用
	int& error_ret_ref()
	{
		int ret = 10;
		ret += 2;
		return ret;
	}

当一个函数声明为非常量型引用时，函数调用可以作为左值，即可以直接对函数的返回值进行赋值操作。而定义为其他类型的返回值的函数会返回右值，只能作为某个值给其他变量赋值。例如以下程序：

	//返回两个数中较小的
	const int& int_cmp(const int &num1, const int &num2)
	{
		return num1 < num2 ? num1 : num2;
	}

	//将较小的数乘2
	void foo
	{
		int num1 = 2, num2 = 3;
		int_cmp(num1, num2) *= 2;	//改句执行后，num1 == 4		
	}

---

##三. const形参和实参

函数的形参可以设为const类型。当采用数值方式传递参数时，形参的const类型会被忽略。如我们定义了下面的函数：

	int func1(const int param)
	{
		//code
	}

在调用该函数时，可以在参数中传入int型或const int型均可。另外，如果定义了两个函数具有相同的函数名和参数，只是其中const类型不同，那么这两个参数的不同实际上会被忽略，导致两个函数发生重复定义的错误。因为在函数的形参被实参初始化时，形参的const会被忽略。

在参数定义为const类型时，形参还可以定义为指针或引用。以引用为例，定义一个参数类型为常量引用的函数如下：

	int func2(const int& param)
	{
		return 2 * param;
	}

我们知道，const int& 引用类型可以指向const int或int型。虽然常引用类型的形参与实参同样是一个实体，但由于其引用时const类型，无论实参是否为const，都不能通过这个引用来修改指向对象的值。因此，如果确定某一个参数只作为输入参数的功能，又必须定义为引用类型，那么应将这个参数定义为常量引用。


---
## 四. 可变形参

在C语言中我们最常见的函数可能就是printf函数了。该函数可以直接输出一行字符串，如：

	printf("Hello, I am printf.\n");

更多时候，我们在字符串中加入一些占位符，作为一些数值、字符和其他类型变量的显示，如：

	printf("Image width: %d, height: %d.\n", imgWidth, imgHeight);

类似printf函数所实现的就是一种可变参数。在目前我们自己定义的大多数函数中，参数的个数和类型都是在声明时确定的，如果调用时出现不一致将导致错误。

事实上，我们在开发C语言程序时就可以定义自己的带有可变参数的函数。在C语言中定义可变参数的函数需要用到如下几个宏定义。使用可变参数功能需包含头文件stdarg.ha。

- **va\_list**：保存va_start, va_arg和va_end所需信息，为访问变长参数列表所必须。
- **va\_start**：初始化va\_list中的参数，初始化的结果供va\_arg和va\_end使用。
- **va\_arg**：从参数列表中按照指定格式取出各个参数。每次调用都会修改va\_list从而使va\_list指向下一个参数。
- **va\_end**：结束可变参数处理。

一个简单的例子如下：

	#include <stdarg.h>

	void va_test(int arg, ...)
	{
		va_list valist;
		va_start(valist, arg);
	
		int count = arg;
	
		while (arg-- > 0)
		{
			printf("%s\n", (char *)va_arg(valist, char *));
		}
		
		va_end(valist);
	}
	
	int _tmain(int argc, _TCHAR* argv[])
	{
		va_test(2, "string1", "string2");
		va_test(3, "test0","test1","test2");
		return 0;
	}
